<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <title>Character Teleprompter</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
    }

    #video-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
    }

    #video-container video {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
  </style>
</head>

<body>
  <div id="video-container">
    <video id="character-video" autoplay playsinline muted loop></video>
  </div>

  <script>
    const videoElement = document.getElementById("character-video");
    const characterName = window.location.pathname.split("/").pop();

    // Function to display the waiting message
    function showWaitingMessage() {
      // Ensure video container exists (should from initial HTML)
      const videoContainer = document.getElementById("video-container");
      if (!videoContainer) {
        console.error("Video container not found!"); // Should not happen
        return;
      }
      videoContainer.style.display = "none"; // Hide video

      // Get or create status message
      let statusDiv = document.getElementById("status-message");
      if (!statusDiv) {
        statusDiv = document.createElement("div");
        statusDiv.id = "status-message";
        statusDiv.style.color = "white";
        statusDiv.style.textAlign = "center";
        statusDiv.style.padding = "40px 20px";
        statusDiv.style.fontSize = "24px";
        statusDiv.style.fontFamily = "sans-serif";
        // Append to body, *not* replacing content
        document.body.appendChild(statusDiv);
      }
      statusDiv.textContent = "Wait for scene to begin";
      statusDiv.style.display = "block"; // Ensure status is visible
    }

    // Function to set up and play the video
    function setupAndPlayVideo(scene) {
      // Ensure video container exists
      const videoContainer = document.getElementById("video-container");
      if (!videoContainer) {
        console.error("Video container not found during setupAndPlayVideo!");
        return;
      }

      // Hide status message if it exists
      const statusDiv = document.getElementById("status-message");
      if (statusDiv) {
        statusDiv.style.display = "none"; // Just hide it
      }

      // Show video container
      videoContainer.style.display = "block";

      // Set the video source and play (videoElement should still be valid)
      const videoSrc = `/database/scenes/${encodeURIComponent(
        scene
      )}/characters/${characterName}/directions.mp4`;
      videoElement.src = videoSrc;

      console.log(`Attempting to play video: ${videoElement.src}`); // Add log

      videoElement.play().catch((err) => {
        console.error("Error playing video:", err, "Src:", videoSrc); // Log src on error
        // Try playing again after a short delay
        setTimeout(() => {
          videoElement
            .play()
            .catch((e) =>
              console.error("Error playing video after retry:", e, "Src:", videoSrc) // Log src on error
            );
        }, 100);
      });
    }

    // ---- INITIAL LOAD ----
    // Show waiting message initially, regardless of fetch result
    showWaitingMessage();

    // Fetch current scene state but DON'T automatically play video.
    // This fetch might be redundant now, but we'll leave it in case
    // it's needed for other logic later or just for consistency.
    // We primarily rely on the WebSocket message now.
    fetch("/teleprompter/api/currentScene")
      .then((res) => res.json())
      .then((data) => {
        // We don't call setupAndPlayVideo(data.scene) here anymore.
        // We just wait for the WebSocket message.
        if (!data.scene) {
          // Optionally, reinforce the waiting message if needed,
          // but showWaitingMessage() above already handled it.
          console.log("Initial fetch: No scene currently set.");
        } else {
          console.log(
            "Initial fetch: Scene is set but waiting for SHOT_START.",
            data.scene
          );
        }
      })
      .catch((err) => {
        console.error("Error fetching initial scene state:", err);
        // Show error or default waiting message
        showWaitingMessage();
        // Optionally display error details somewhere
        let statusDiv = document.getElementById("status-message");
        if (statusDiv) statusDiv.textContent += ` (Error: ${err.message})`;
      });

    // ---- WEBSOCKET HANDLING ----
    const ws = new WebSocket("ws://" + window.location.host);

    ws.onmessage = function (event) {
      try {
        const data = JSON.parse(event.data);
        console.log("WebSocket message received:", data);

        if (data.type === "SHOT_START") {
          console.log(
            "SHOT_START received, playing video for scene:",
            data.scene.directory
          );
          // This is now the ONLY place we start the video
          setupAndPlayVideo(data.scene.directory);
        } else if (data.type === "TELEPROMPTER_CONTROL") {
          // Existing pause/play logic for mid-scene control
          if (data.action === "PAUSE") {
            console.log("Pausing video via WebSocket");
            videoElement.pause();
          } else if (data.action === "PLAY") {
            console.log("Resuming video via WebSocket");
            videoElement.play().catch((err) => {
              console.error("Error resuming video:", err);
            });
          }
        } else if (
          data.type === "SCENE_ENDED" ||
          data.type === "SYSTEM_RESET"
        ) {
          // Handle scene ending or reset
          console.log(
            "Scene ended or system reset, showing waiting message."
          );
          showWaitingMessage(); // Go back to waiting state
        } else if (data.type === "TELEPROMPTER_STATUS") {
          // Handle status updates
          console.log("TELEPROMPTER_STATUS received:", data.message);
          // Use the showWaitingMessage function structure, but update the text
          let statusDiv = document.getElementById("status-message");
          const videoContainer = document.getElementById("video-container"); // Get container ref

          if (!statusDiv) {
            // If the status div doesn't exist (e.g., video was playing), create it
            statusDiv = document.createElement("div");
            statusDiv.id = "status-message";
            statusDiv.style.color = "white";
            statusDiv.style.textAlign = "center";
            statusDiv.style.padding = "40px 20px";
            statusDiv.style.fontSize = "24px";
            statusDiv.style.fontFamily = "sans-serif";
            // !!! Don't clear body !!!
            document.body.appendChild(statusDiv); // Append instead
          }

          // Hide video container when showing status
          if (videoContainer) videoContainer.style.display = "none";

          // Update the text content and ensure status is visible
          statusDiv.textContent = data.message;
          statusDiv.style.display = 'block';
        }
      } catch (e) {
        console.error(
          "Error processing WebSocket message:",
          e,
          "Raw data:",
          event.data
        );
      }
    };

    ws.onerror = function (error) {
      console.error("WebSocket error:", error);
      showWaitingMessage(); // Show waiting message on connection error too
      let statusDiv = document.getElementById("status-message");
      if (statusDiv) statusDiv.textContent += " (WebSocket Error)";
    };

    ws.onclose = function () {
      console.log("WebSocket connection closed");
      showWaitingMessage(); // Show waiting message on connection close
      let statusDiv = document.getElementById("status-message");
      if (statusDiv) statusDiv.textContent += " (WebSocket Closed)";
    };
  </script>
</body>

</html>