<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>AI Director Interface</title>
    <link rel="stylesheet" href="/views/styles/main.css" />
  </head>

  <body>
    <div class="main-content">
      <h1>AI Director Shots</h1>
      <div class="scene-container">
        <% scenes.forEach((scene, idx)=> { %>
        <div
          class="scene-card"
          onclick="initScene('<%= encodeURIComponent(scene.directory) %>')"
        >
          <div class="scene-title">
            Scene #<%= idx + 1 %>: <%= scene.description %>
          </div>
          <img
            src="./database/scenes/<%= scene.directory %>/thumbnail.jpg"
            alt="<%= scene.description %>"
          />
        </div>
        <% }); %>
      </div>
      <div id="videos"></div>
      <div class="controls-section">
        <h2>Console Output</h2>
        <div id="console-output"></div>
      </div>
    </div>
    <div class="sidebar">
      <div class="controls-section">
        <h2>Camera Controls</h2>
        <div id="cameraControls">
          <!-- Camera controls will be populated by CameraManager -->
        </div>
        <button onclick="cameraManager.addCamera()">Add Camera</button>
      </div>
      <div id="status"></div>
      <div class="controls-section">
        <h2>Controls</h2>
        <div id="buttons">
          <button
            id="actionBtn"
            onclick="action()"
            style="
              display: none;
              background-color: #e8f5e9;
              border-color: #4caf50;
              color: #2e7d32;
            "
          >
            Action!
          </button>
          <button
            id="actorsReadyBtn"
            onclick="actorsReady()"
            style="
              display: none;
              background-color: #e8f5e9;
              border-color: #4caf50;
              color: #2e7d32;
            "
          >
            Actors are Ready
          </button>
          <button onclick="recordVideo()">
            Record 3s Video & Process Pose
          </button>
          <button id="voiceBypassBtn" onclick="toggleVoiceBypass()">
            Enable Voice Bypass
          </button>

          <button onclick="testConsole()">Test Console</button>
          <button onclick="loadActors()">Load New Actors</button>

          <div class="audio-controls">
            <div class="group-label">Audio Controls</div>
            <button onclick="testAudioRecord()" class="success-btn">
              üé§ Record Audio (5s)
            </button>
            <button onclick="playLastRecording()" class="info-btn">
              ‚ñ∂Ô∏è Play Last Recording
            </button>
            <button onclick="clearAudio()" class="warning-btn">
              üóëÔ∏è Clear Audio
            </button>
          </div>

          <div class="teleprompter-button-group">
            <div class="group-label">Teleprompter Controls</div>
            <button onclick="openTeleprompter()">Open Teleprompter</button>
            <button onclick="openCharacterTeleprompter('alan')">
              Open Alan's Teleprompter
            </button>
            <button onclick="openCharacterTeleprompter('ellie')">
              Open Ellie's Teleprompter
            </button>
            <button onclick="testTeleprompter()">Test Teleprompter</button>
            <button onclick="testTeleprompterVideo()">
              Test Teleprompter Video
            </button>
            <button onclick="clearTeleprompter()">Clear Teleprompter</button>
            <button onclick="pauseAllTeleprompters()" class="warning-btn">
              ‚è∏Ô∏è Pause All Teleprompters
            </button>
            <button onclick="playAllTeleprompters()" class="success-btn">
              ‚ñ∂Ô∏è Resume All Teleprompters
            </button>
          </div>
        </div>
      </div>

      <div class="controls-section">
        <h2>Teleprompter Preview</h2>
        <div class="teleprompter-container">
          <iframe id="teleprompter-frame" src="/teleprompter"></iframe>
        </div>
      </div>
    </div>

    <script>
      // WebSocket connection for real-time updates
      const ws = new WebSocket("ws://" + window.location.host);

      ws.onopen = function () {
        console.log("WebSocket connection established");
        appendToConsole("WebSocket connected", "info");

        // Fetch initial voice bypass state from server
        fetch("/getVoiceBypass")
          .then((res) => res.json())
          .then((data) => {
            voiceBypassEnabled = data.enabled;
            const btn = document.getElementById("voiceBypassBtn");
            if (btn) {
              btn.textContent = voiceBypassEnabled
                ? "Disable Voice Bypass"
                : "Enable Voice Bypass";
              btn.style.backgroundColor = voiceBypassEnabled
                ? "#ff4444"
                : "#4CAF50";
            }
          })
          .catch((err) => {
            console.error("Error fetching voice bypass state:", err);
          });
      };

      ws.onerror = function (error) {
        console.error("WebSocket error:", error);
        appendToConsole("WebSocket error: " + error.message, "error");
      };

      ws.onclose = function () {
        console.log("WebSocket connection closed");
        appendToConsole("WebSocket connection closed", "warn");
      };

      // Voice bypass state
      let voiceBypassEnabled = true;

      function toggleVoiceBypass() {
        voiceBypassEnabled = !voiceBypassEnabled;
        const btn = document.getElementById("voiceBypassBtn");
        btn.textContent = voiceBypassEnabled
          ? "Disable Voice Bypass"
          : "Enable Voice Bypass";
        btn.style.backgroundColor = voiceBypassEnabled ? "#ff4444" : "#4CAF50";

        // Send the bypass state to the server
        fetch("/setVoiceBypass", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ enabled: voiceBypassEnabled }),
        })
          .then((res) => res.json())
          .then((info) => {
            document.getElementById("status").innerText = info.message;
          })
          .catch((err) => {
            console.error(err);
            document.getElementById("status").innerText = "Error: " + err;
          });
      }

      ws.onmessage = function (event) {
        console.log("Received WebSocket message:", event.data);
        const data = JSON.parse(event.data);
        console.log("Parsed WebSocket data:", data);
        if (data.type === "CONSOLE") {
          console.log("Handling console message:", data.message);
          appendToConsole(data.message, data.level);
        } else if (data.type === "ACTORS_CALLED") {
          document.getElementById("actorsReadyBtn").style.display =
            "inline-block";
          document.getElementById("status").innerText =
            "Waiting for actors to be ready...";
        } else if (data.type === "ACTORS_READY") {
          document.getElementById("actorsReadyBtn").style.display = "none";
          document.getElementById("actionBtn").style.display = "inline-block";
          document.getElementById("status").innerText =
            "Actors are ready to perform!";
        }
      };

      function appendToConsole(message, level = "info") {
        const console = document.getElementById("console-output");
        const timestamp = new Date().toLocaleTimeString();
        const entry = document.createElement("div");
        entry.className = level;
        entry.innerHTML =
          '<span class="timestamp">[' + timestamp + "]</span> " + message;
        console.appendChild(entry);
        console.scrollTop = console.scrollHeight;
      }

      function openTeleprompter() {
        window.open("/teleprompter", "teleprompter", "width=800,height=600");
      }

      function openCharacterTeleprompter(character) {
        const url = `/teleprompter/${character}`;
        window.open(url, `teleprompter-${character}`, "width=800,height=600");
      }

      function testTeleprompter() {
        // First send a message with an image
        fetch("/teleprompter/updateTeleprompter", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            text: "This is a test message with an image for the teleprompter.",
            image: "/database/test_content/headshot.jpg",
          }),
        });

        // Then send a message without an image
        setTimeout(() => {
          fetch("/teleprompter/updateTeleprompter", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              text: "This is a test message without an image for the teleprompter.",
            }),
          });
        }, 3000); // Wait 3 seconds before sending the second message
      }

      function testTeleprompterVideo() {
        fetch("/teleprompter/playTeleprompterVideo", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            videoPath: "/database/test_content/freefall.mp4",
          }),
        });
      }

      function clearTeleprompter() {
        fetch("/teleprompter/clearTeleprompter", { method: "POST" })
          .then((res) => res.json())
          .then((info) => {
            document.getElementById("status").innerText = info.message;
          })
          .catch((err) => {
            console.error(err);
            document.getElementById("status").innerText = "Error: " + err;
          });
      }

      function initScene(directory) {
        fetch("/initScene/" + encodeURIComponent(directory))
          .then((res) => res.json())
          .then((info) => {
            document.getElementById("status").innerText = info.message;
          })
          .catch((err) => {
            console.error(err);
            document.getElementById("status").innerText = "Error: " + err;
          });
      }

      function actorsReady() {
        document.getElementById("status").innerText =
          "Notifying system that actors are ready...";
        fetch("/actorsReady", { method: "POST" })
          .then((res) => res.json())
          .then((info) => {
            document.getElementById("status").innerText = info.message;
          })
          .catch((err) => {
            console.error(err);
            document.getElementById("status").innerText = "Error: " + err;
          });
      }

      function recordVideo() {
        document.getElementById("status").innerText = "Recording video...";
        fetch("/camera/recordVideo")
          .then((res) => res.json())
          .then((info) => {
            if (!info.success) {
              document.getElementById("status").innerText =
                "Error: " + info.message;
              return;
            }
            document.getElementById("status").innerText =
              info.message || "Video recorded.";
            const vidDiv = document.getElementById("videos");
            vidDiv.innerHTML = `
            <h3>Original Video</h3>
            <video controls src="/video/${info.originalName}"></video>
            <h3>Overlay Video</h3>
            <video controls src="/video/${info.overlayName}"></video>
          `;
          })
          .catch((err) => {
            console.error(err);
            document.getElementById("status").innerText = "Error: " + err;
          });
      }

      function updatePTZ() {
        // Get slider values directly - they are already in the correct step size
        const data = {
          pan: parseInt(document.getElementById("panSlider").value),
          tilt: parseInt(document.getElementById("tiltSlider").value),
          zoom: parseInt(document.getElementById("zoomSlider").value),
        };

        // Update display values - convert hardware values to physical degrees
        document.getElementById("panValue").textContent =
          data.pan === 0 ? "0¬∞" : ((data.pan / 468000) * 140).toFixed(1) + "¬∞";
        document.getElementById("tiltValue").textContent =
          data.tilt === 0
            ? "0¬∞"
            : ((data.tilt / 324000) * (data.tilt > 0 ? 30 : -70)).toFixed(1) +
              "¬∞";
        document.getElementById("zoomValue").textContent = data.zoom + "%";

        // Send to server
        fetch("/camera/ptz", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(data),
        });
      }

      function selectCamera(camera) {
        if (!camera) return;

        fetch("/camera/selectCamera", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ camera }),
        })
          .then((res) => res.json())
          .then((data) => {
            if (data.success) {
              document.getElementById("status").innerText = data.message;
              // Reinitialize webcam with selected camera
              initWebcam(camera);
            } else {
              document.getElementById("status").innerText =
                "Error: " + data.message;
            }
          })
          .catch((err) => {
            document.getElementById("status").innerText = "Error: " + err;
          });
      }

      // Initialize camera controls when page loads
      window.addEventListener("load", async () => {
        // Don't automatically initialize webcam on load
        // Let the user select a camera first
        initSceneControls();
      });

      function action() {
        document.getElementById("status").innerText = "Starting action...";
        fetch("/action", { method: "POST" })
          .then((res) => res.json())
          .then((info) => {
            document.getElementById("status").innerText = info.message;
          })
          .catch((err) => {
            console.error(err);
            document.getElementById("status").innerText = "Error: " + err;
          });
      }

      function testConsole() {
        fetch("/testConsole", { method: "POST" })
          .then((res) => res.json())
          .then((info) => {
            document.getElementById("status").innerText = info.message;
          })
          .catch((err) => {
            console.error(err);
            document.getElementById("status").innerText = "Error: " + err;
          });
      }

      function loadActors() {
        const input = document.createElement("input");
        input.type = "file";
        input.click();
      }

      function pauseAllTeleprompters() {
        ws.send(
          JSON.stringify({
            type: "TELEPROMPTER_CONTROL",
            action: "PAUSE",
          })
        );
        appendToConsole("Paused all teleprompters", "info");
      }

      function playAllTeleprompters() {
        ws.send(
          JSON.stringify({
            type: "TELEPROMPTER_CONTROL",
            action: "PLAY",
          })
        );
        appendToConsole("Resumed all teleprompters", "info");
      }

      function testAudioRecord() {
        // Request microphone access
        navigator.mediaDevices
          .getUserMedia({ audio: true })
          .then((stream) => {
            const mediaRecorder = new MediaRecorder(stream, {
              mimeType: "audio/webm", // Use webm for better compatibility
            });
            const audioChunks = [];

            mediaRecorder.ondataavailable = (e) => {
              audioChunks.push(e.data);
            };

            mediaRecorder.onstop = async () => {
              // Convert to wav format
              const audioBlob = new Blob(audioChunks, { type: "audio/webm" });

              // Create FormData and append the blob
              const formData = new FormData();
              formData.append("audio", audioBlob, "recording.webm");

              try {
                const response = await fetch("/recordAudio", {
                  method: "POST",
                  body: formData,
                });
                const data = await response.json();
                appendToConsole(`Audio recorded: ${data.filename}`, "info");
                // Store the filename for playback
                window.lastAudioRecording = data.filename;
              } catch (err) {
                console.error("Error recording audio:", err);
                appendToConsole("Error recording audio", "error");
              }
            };

            // Start recording
            mediaRecorder.start(100); // Collect data every 100ms
            appendToConsole("Recording audio for 5 seconds...", "info");

            // Stop after 5 seconds
            setTimeout(() => {
              mediaRecorder.stop();
              stream.getTracks().forEach((track) => track.stop());
            }, 5000);
          })
          .catch((err) => {
            console.error("Error accessing microphone:", err);
            appendToConsole("Error accessing microphone", "error");
          });
      }

      function playLastRecording() {
        if (!window.lastAudioRecording) {
          appendToConsole("No audio recording available to play", "warn");
          return;
        }

        const audio = new Audio(`/temp/${window.lastAudioRecording}`);
        audio
          .play()
          .then(() => {
            appendToConsole("Playing last recording...", "info");
          })
          .catch((err) => {
            console.error("Error playing audio:", err);
            appendToConsole("Error playing audio", "error");
          });
      }

      function clearAudio() {
        if (!window.lastAudioRecording) {
          appendToConsole("No audio recording to clear", "warn");
          return;
        }

        fetch("/clearAudio", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ filename: window.lastAudioRecording }),
        })
          .then((res) => res.json())
          .then((data) => {
            if (data.success) {
              window.lastAudioRecording = null;
              appendToConsole("Audio recording cleared", "info");
            } else {
              appendToConsole("Error clearing audio: " + data.message, "error");
            }
          })
          .catch((err) => {
            console.error("Error clearing audio:", err);
            appendToConsole("Error clearing audio", "error");
          });
      }

      // Camera management
      class CameraManager {
        constructor() {
          this.cameras = [];
          this.cameraElements = new Map();
          this.availableDevices = [];
          this.ptzDevices = [];
          this.deviceMap = new Map(); // Map browser device IDs to device paths
        }

        async initialize() {
          try {
            // First try to get devices without requesting permissions
            let devices = await navigator.mediaDevices.enumerateDevices();
            this.availableDevices = devices.filter(
              (device) => device.kind === "videoinput"
            );

            // If we don't have any device labels, request camera permission
            if (
              this.availableDevices.length > 0 &&
              !this.availableDevices[0].label
            ) {
              try {
                const stream = await navigator.mediaDevices.getUserMedia({
                  video: true,
                });
                // Stop the stream immediately
                stream.getTracks().forEach((track) => track.stop());
                // Re-enumerate devices to get labels
                devices = await navigator.mediaDevices.enumerateDevices();
                this.availableDevices = devices.filter(
                  (device) => device.kind === "videoinput"
                );
              } catch (err) {
                console.log(
                  "Permission not granted or no camera available:",
                  err
                );
              }
            }

            console.log("Browser detected devices:", this.availableDevices);

            // Get configured cameras from the server
            const camerasResponse = await fetch("/camera/cameras");
            this.cameras = await camerasResponse.json();

            console.log("Server cameras:", this.cameras);

            // Get the device paths from the server
            const devicesResponse = await fetch("/camera/devices");
            const serverDevices = await devicesResponse.json();

            // Create a mapping between browser device IDs and server device paths
            this.deviceMap.clear();
            for (const serverDevice of serverDevices) {
              // Extract the device number from the path (e.g., "video2" from "/dev/video2")
              const deviceNum = serverDevice.path.split("/").pop();

              // Try to find a matching browser device
              for (const browserDevice of this.availableDevices) {
                // Check if the device label contains the device number
                if (
                  browserDevice.label &&
                  (browserDevice.label.includes(deviceNum) || // Direct match
                    browserDevice.label.includes(serverDevice.name) || // Match by device name
                    (serverDevice.name &&
                      browserDevice.label.includes(
                        serverDevice.name.split(" ")[0]
                      ))) // Match by first word of device name
                ) {
                  this.deviceMap.set(browserDevice.deviceId, serverDevice.path);
                  console.log(
                    `Mapped browser device ${browserDevice.label} (${browserDevice.deviceId}) to ${serverDevice.path}`
                  );
                  break;
                }
              }
            }

            // Log any unmapped devices
            for (const device of this.availableDevices) {
              if (!this.deviceMap.has(device.deviceId)) {
                console.log(
                  `Could not map browser device: ${device.label} (${device.deviceId})`
                );
              }
            }

            // Only get PTZ devices if we have cameras
            if (this.cameras.length > 0) {
              const ptzResponse = await fetch("/camera/ptz-devices");
              this.ptzDevices = await ptzResponse.json();
            } else {
              this.ptzDevices = [];
            }

            this.renderCameraControls();
          } catch (err) {
            console.error("Error loading cameras:", err);
            document.getElementById("status").innerText =
              "Error loading cameras: " + err.message;
          }
        }

        // Helper method to start preview with device path
        async startPreview(cameraName, devicePath) {
          try {
            // First try with exact device path from server
            const videoElement = document.getElementById(
              `preview-${cameraName}`
            );
            if (!videoElement) return; // Element not found

            let deviceId = devicePath;

            // For Linux device paths, try to match with available devices
            if (devicePath.startsWith("/dev/")) {
              // Try to find a matching device in browser devices
              for (const device of this.availableDevices) {
                if (
                  device.label &&
                  device.label.includes(devicePath.substring(5))
                ) {
                  deviceId = device.deviceId;
                  break;
                }
              }

              // If no match, just use the first available device
              if (deviceId === devicePath && this.availableDevices.length > 0) {
                deviceId = this.availableDevices[0].deviceId;
              }
            }

            const constraints = {
              video: {
                deviceId: { exact: deviceId },
                frameRate: { ideal: 30 },
                aspectRatio: { ideal: 1.7777777778 }, // 16:9
                width: { ideal: 1920 },
                height: { ideal: 1080 },
              },
            };

            const stream = await navigator.mediaDevices.getUserMedia(
              constraints
            );
            videoElement.srcObject = stream;

            console.log(
              `Started preview for ${cameraName} with device ${deviceId}`
            );
          } catch (err) {
            console.error(`Failed to start preview for ${cameraName}:`, err);
          }
        }

        async addCamera() {
          const name = `Camera ${this.cameras.length + 1}`;
          try {
            const response = await fetch("/camera/add", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ name }),
            });

            if (response.ok) {
              await this.initialize(); // Refresh the camera list
            }
          } catch (err) {
            console.error("Error adding camera:", err);
          }
        }

        async removeCamera(name) {
          try {
            const response = await fetch("/camera/remove", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ name }),
            });

            if (response.ok) {
              await this.initialize(); // Refresh the camera list
            }
          } catch (err) {
            console.error("Error removing camera:", err);
          }
        }

        renderCameraControls() {
          const container = document.getElementById("cameraControls");
          container.innerHTML = "";

          this.cameras.forEach((camera) => {
            const cameraElement = this.createCameraElement(camera);
            container.appendChild(cameraElement);
            this.cameraElements.set(camera.name, cameraElement);
          });
        }

        createCameraElement(camera) {
          const div = document.createElement("div");
          div.className = "camera-control";

          // Extract the camera model name from the full path
          const cameraModel =
            camera.previewDevice && camera.previewDevice.includes("/")
              ? camera.previewDevice.split("/").pop()
              : "Unknown";

          div.innerHTML = `
            <div class="camera-header">
              <h3>${camera.name}</h3>
              <button onclick="cameraManager.removeCamera('${
                camera.name
              }')" class="remove-btn">Remove</button>
            </div>
            <div class="camera-preview">
              <video id="preview-${camera.name}" autoplay playsinline></video>
              <div class="device-info">Using: ${
                camera.previewDevice || "No device selected"
              }</div>
            </div>
            <div class="camera-settings">
              <div class="setting-group">
                <label>Preview Device:</label>
                <select class="preview-device" onchange="cameraManager.updatePreviewDevice('${
                  camera.name
                }', this.value)">
                  <option value="">Select Preview Device</option>
                  ${this.availableDevices
                    .map(
                      (device) => `
                    <option value="${device.deviceId}" ${
                        device.label &&
                        camera.previewDevice &&
                        device.label.includes(cameraModel)
                          ? "selected"
                          : ""
                      }>
                      ${device.label || `Device ${device.deviceId}`}
                    </option>
                  `
                    )
                    .join("")}
                </select>
              </div>
              <div class="setting-group">
                <label>Recording Device:</label>
                <select class="recording-device" onchange="cameraManager.updateRecordingDevice('${
                  camera.name
                }', this.value)">
                  <option value="">Select Recording Device</option>
                  ${this.availableDevices
                    .map((device) => {
                      const devicePath = this.deviceMap.get(device.deviceId);
                      return `
                    <option value="${devicePath}" ${
                        devicePath === camera.recordingDevice ? "selected" : ""
                      }>
                      ${device.label || `Device ${device.deviceId}`} (${
                        devicePath || "Unknown"
                      })
                    </option>
                  `;
                    })
                    .join("")}
                </select>
              </div>
              <div class="setting-group">
                <label>PTZ Device:</label>
                <select class="ptz-device" onchange="cameraManager.updatePTZDevice('${
                  camera.name
                }', this.value)">
                  <option value="">Select PTZ Device</option>
                  ${this.ptzDevices
                    .map(
                      (device) => `
                    <option value="${device.path}" ${
                        device.path === camera.ptzDevice ? "selected" : ""
                      }>
                      ${device.name}
                    </option>
                  `
                    )
                    .join("")}
                </select>
              </div>
              <div class="ptz-controls-container">
                ${
                  camera.ptzDevice
                    ? `
                  <div class="ptz-controls">
                    <div class="ptz-slider">
                      <label>Pan: <span id="pan-value-${camera.name}">0¬∞</span></label>
                      <input type="range" min="-468000" max="468000" step="3600" value="0" 
                            onchange="cameraManager.updatePTZ('${camera.name}', 'pan', this.value)">
                    </div>
                    <div class="ptz-slider">
                      <label>Tilt: <span id="tilt-value-${camera.name}">0¬∞</span></label>
                      <input type="range" min="-324000" max="324000" step="3600" value="0"
                            onchange="cameraManager.updatePTZ('${camera.name}', 'tilt', this.value)">
                    </div>
                    <div class="ptz-slider">
                      <label>Zoom: <span id="zoom-value-${camera.name}">0%</span></label>
                      <input type="range" min="0" max="100" step="1" value="0"
                            onchange="cameraManager.updatePTZ('${camera.name}', 'zoom', this.value)">
                    </div>
                  </div>
                `
                    : ""
                }
              </div>
              <button onclick="cameraManager.recordVideo('${
                camera.name
              }')">Record Video</button>
            </div>
          `;
          return div;
        }

        async updatePreviewDevice(cameraName, deviceId) {
          try {
            // Update on the server - note that deviceId here is the browser's deviceId
            await fetch("/camera/preview-device", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ cameraName, deviceId }),
            });

            const videoElement = document.getElementById(
              `preview-${cameraName}`
            );

            if (deviceId) {
              // Start preview
              const constraints = {
                video: {
                  deviceId: { exact: deviceId },
                  frameRate: { ideal: 30 },
                  aspectRatio: { ideal: 1.7777777778 }, // 16:9
                  width: { ideal: 1920 },
                  height: { ideal: 1080 },
                },
              };

              try {
                const stream = await navigator.mediaDevices.getUserMedia(
                  constraints
                );
                videoElement.srcObject = stream;

                // Update the device info display
                const deviceInfoElement = videoElement.nextElementSibling;
                if (
                  deviceInfoElement &&
                  deviceInfoElement.className === "device-info"
                ) {
                  // Find the device label
                  const device = this.availableDevices.find(
                    (d) => d.deviceId === deviceId
                  );
                  deviceInfoElement.textContent = `Using: ${
                    device ? device.label : deviceId
                  }`;
                }
              } catch (err) {
                console.error("Error accessing camera:", err);
                document.getElementById(
                  "status"
                ).innerText = `Error accessing camera: ${err.message}`;
              }
            } else {
              // Stop preview
              if (videoElement.srcObject) {
                videoElement.srcObject
                  .getTracks()
                  .forEach((track) => track.stop());
                videoElement.srcObject = null;

                // Update the device info display
                const deviceInfoElement = videoElement.nextElementSibling;
                if (
                  deviceInfoElement &&
                  deviceInfoElement.className === "device-info"
                ) {
                  deviceInfoElement.textContent = "No device selected";
                }
              }
            }
          } catch (err) {
            console.error("Error updating preview device:", err);
          }
        }

        async updateRecordingDevice(cameraName, deviceId) {
          try {
            await fetch("/camera/recording-device", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ cameraName, deviceId }),
            });
          } catch (err) {
            console.error("Error updating recording device:", err);
          }
        }

        async updatePTZDevice(cameraName, deviceId) {
          try {
            // Only update the PTZ device on the server
            // This should not affect the preview or recording devices
            await fetch("/camera/ptz-device", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ cameraName, deviceId }),
            });

            console.log(`Updated PTZ device for ${cameraName} to ${deviceId}`);

            // Refresh only the PTZ controls, not the entire camera
            const camera = this.cameras.find((cam) => cam.name === cameraName);
            if (camera) {
              // Update the camera's PTZ device locally
              camera.ptzDevice = deviceId;

              // Get the camera element
              const cameraElement = this.cameraElements.get(cameraName);
              if (cameraElement) {
                // Find the PTZ controls container
                const ptzControlsContainer = cameraElement.querySelector(
                  ".ptz-controls-container"
                );
                if (ptzControlsContainer) {
                  // Only update the PTZ controls
                  if (deviceId) {
                    ptzControlsContainer.innerHTML = `
                      <div class="ptz-controls">
                        <div class="ptz-slider">
                          <label>Pan: <span id="pan-value-${cameraName}">0¬∞</span></label>
                          <input type="range" min="-468000" max="468000" step="3600" value="0" 
                                onchange="cameraManager.updatePTZ('${cameraName}', 'pan', this.value)">
                        </div>
                        <div class="ptz-slider">
                          <label>Tilt: <span id="tilt-value-${cameraName}">0¬∞</span></label>
                          <input type="range" min="-324000" max="324000" step="3600" value="0"
                                onchange="cameraManager.updatePTZ('${cameraName}', 'tilt', this.value)">
                        </div>
                        <div class="ptz-slider">
                          <label>Zoom: <span id="zoom-value-${cameraName}">0%</span></label>
                          <input type="range" min="0" max="100" step="1" value="0"
                                onchange="cameraManager.updatePTZ('${cameraName}', 'zoom', this.value)">
                        </div>
                      </div>
                    `;
                  } else {
                    ptzControlsContainer.innerHTML = "";
                  }
                }
              }
            }
          } catch (err) {
            console.error("Error updating PTZ device:", err);
          }
        }

        async updatePTZ(cameraName, control, value) {
          const data = { cameraName };
          data[control] = parseInt(value);

          // Update display - convert hardware values to physical degrees
          const displayValue =
            control === "zoom"
              ? `${value}%`
              : control === "pan"
              ? value === 0
                ? "0¬∞"
                : ((value / 468000) * 140).toFixed(1) + "¬∞"
              : value === 0
              ? "0¬∞"
              : ((value / 324000) * (value > 0 ? 30 : -70)).toFixed(1) + "¬∞";

          document.getElementById(
            `${control}-value-${cameraName}`
          ).textContent = displayValue;

          try {
            await fetch("/camera/ptz", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(data),
            });
          } catch (err) {
            console.error("Error updating PTZ:", err);
          }
        }

        async recordVideo(cameraName) {
          try {
            const response = await fetch(
              `/camera/recordVideo?cameraName=${encodeURIComponent(cameraName)}`
            );
            const info = await response.json();

            if (!info.success) {
              document.getElementById("status").innerText =
                "Error: " + info.message;
              return;
            }

            document.getElementById("status").innerText =
              info.message || "Video recorded.";
            const vidDiv = document.getElementById("videos");
            vidDiv.innerHTML = `
              <h3>Original Video</h3>
              <video controls src="/video/${info.originalName}"></video>
              <h3>Overlay Video</h3>
              <video controls src="/video/${info.overlayName}"></video>
            `;
          } catch (err) {
            console.error(err);
            document.getElementById("status").innerText = "Error: " + err;
          }
        }
      }

      // Initialize camera manager
      const cameraManager = new CameraManager();
      window.addEventListener("load", () => cameraManager.initialize());
    </script>

    <style>
      .camera-control {
        margin-bottom: 20px;
        padding: 15px;
        border: 1px solid #ccc;
        border-radius: 5px;
      }

      .camera-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }

      .remove-btn {
        background-color: #ff4444;
        color: white;
        border: none;
        padding: 5px 10px;
        border-radius: 3px;
        cursor: pointer;
      }

      .camera-preview video {
        width: 100%;
        max-height: 200px;
        background: #000;
      }

      .camera-settings {
        margin-top: 10px;
      }

      .setting-group {
        margin: 10px 0;
      }

      .setting-group label {
        display: block;
        margin-bottom: 5px;
      }

      .setting-group select {
        width: 100%;
        padding: 5px;
      }

      .ptz-controls {
        margin-top: 15px;
      }

      .ptz-slider {
        margin: 10px 0;
      }

      .ptz-slider input {
        width: 100%;
      }

      .ptz-slider label {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
    </style>
  </body>
</html>
