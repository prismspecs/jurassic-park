<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Director Control Panel</title>
  <link rel="stylesheet" href="/views/styles/main.css" />
  <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>

<body>
  <div class="page-layout">
    <!-- NEW Left Sidebar -->
    <div class="left-sidebar">
      <div class="controls-section card">
        <h2>Session Management</h2>
        <p><strong>Current Session:</strong> <span id="current-session-id">
            <%= currentSessionId %>
          </span></p>
        <p><strong>Existing Sessions:</strong></p>
        <div id="existing-sessions-list" class="session-list">
          <% if (existingSessions && existingSessions.length> 0) { %>
            <% existingSessions.forEach(session=> { %>
              <div class="session-item">
                <button class="session-button <%= session === currentSessionId ? 'active' : '' %>"
                  onclick="selectSession('<%= session %>')">
                  <%= session %>
                </button>
                <% if (session !==currentSessionId) { %>
                  <button class="delete-session-button" title="Delete session <%= session %>"
                    onclick="deleteSession('<%= session %>')">
                    ‚ùå
                  </button>
                  <% } %>
              </div>
              <% }); %>
                <% } else { %>
                  <p>No other sessions found.</p>
                  <% } %>
        </div>
      </div>

      <!-- MOVED Teleprompter Preview Here -->
      <div class="controls-section card">
        <h2>Teleprompter Preview</h2>
        <div class="teleprompter-container">
          <iframe id="teleprompter-frame" src="/teleprompter"></iframe>
        </div>
      </div>
      <!-- End Teleprompter Preview -->
    </div>
    <!-- End Left Sidebar -->

    <!-- ADD Resizer Handle -->
    <div class="resizer-handle" id="resizer-left-main"></div>

    <!-- Main Content Area -->
    <div class="main-content">
      <h1>AI Director Shots</h1>
      <div class="scene-container">
        <% scenes.forEach((scene, idx)=> { %>
          <div class="scene-card" onclick="initScene('<%= encodeURIComponent(scene.directory) %>')">
            <div class="scene-title">
              Scene #<%= idx + 1 %>: <%= scene.description %>
            </div>
            <img src="./database/scenes/<%= scene.directory %>/thumbnail.jpg" alt="<%= scene.description %>" />
          </div>
          <% }); %>
      </div>

      <!-- MOVED Console Output First -->
      <div class="controls-section card">
        <h2>Console Output</h2>
        <div id="console-output"></div>
      </div>
      <!-- End Console Output -->

      <!-- MOVED Video Display Below Console -->
      <div id="videos"></div>
      <!-- End Video Display -->

    </div>
    <!-- End Main Content Area -->

    <!-- ADD Resizer Handle -->
    <div class="resizer-handle" id="resizer-main-right"></div>

    <!-- Right Sidebar -->
    <div class="sidebar">
      <div class="controls-section card">
        <h2>Camera Controls</h2>
        <div id="cameraControls">
          <!-- Camera controls will be populated by CameraManager -->
        </div>
        <button onclick="cameraManager.addCamera()">Add Camera</button>
      </div>

      <div id="status"></div>

      <div class="controls-section card">
        <h2>Controls</h2>
        <div id="buttons">
          <div class="recording-options">
            <label for="recording-pipeline">Recording Pipeline:</label>
            <select id="recording-pipeline" class="form-control" onchange="handlePipelineChange(this.value)">
              <option value="gstreamer" selected>GStreamer (Default)</option>
              <option value="ffmpeg">FFmpeg</option>
            </select>
          </div>
          <div class="recording-options">
            <label for="recording-resolution">Recording Resolution:</label>
            <select id="recording-resolution" class="form-control">
              <option value="1920x1080" selected>1920x1080 (1080p)</option>
              <option value="3840x2160">3840x2160 (4K)</option>
              <option value="1280x720">1280x720 (720p)</option>
              <option value="640x480">640x480 (VGA)</option>
            </select>
          </div>
          <button id="actionBtn" onclick="action()"
            style="display: none; background-color: #e8f5e9; border-color: #4caf50; color: #2e7d32;">Action!</button>
          <button id="actorsReadyBtn" onclick="actorsReady()"
            style="display: none; background-color: #e8f5e9; border-color: #4caf50; color: #2e7d32;">Actors are
            Ready</button>
          <button onclick="recordVideo()">Test Record Video & Process Pose</button>
          <button id="voiceBypassBtn" onclick="toggleVoiceBypass()">Enable Voice Bypass</button>
          <button onclick="testConsole()">Test Console</button>

          <div class="actor-loading">
            <label for="actorFiles">Load Actors:</label>
            <input type="file" id="actorFiles" multiple accept=".json, .jpg, .jpeg, .png">
            <button id="loadActorsBtn">Load Selected</button>
            <p id="loadActorsStatus"></p>
          </div>

          <div class="audio-controls">
            <div class="group-label">Audio Controls</div>
            <button onclick="testAudioRecord()" class="success-btn">üé§ Record Audio (5s)</button>
            <button onclick="playLastRecording()" class="info-btn">‚ñ∂Ô∏è Play Last Recording</button>
            <button onclick="clearAudio()" class="warning-btn">üóëÔ∏è Clear Audio</button>
          </div>
          <div class="teleprompter-button-group">
            <div class="group-label">Teleprompter Controls</div>
            <button onclick="openTeleprompter()">Open Teleprompter</button>
            <button onclick="openCharacterTeleprompter('alan')">Open Alan's Teleprompter</button>
            <button onclick="openCharacterTeleprompter('ellie')">Open Ellie's Teleprompter</button>
            <button onclick="testTeleprompter()">Test Teleprompter</button>
            <button onclick="testTeleprompterVideo()">Test Teleprompter Video</button>
            <button onclick="clearTeleprompter()">Clear Teleprompter</button>
            <button onclick="pauseAllTeleprompters()" class="warning-btn">‚è∏Ô∏è Pause All Teleprompters</button>
            <button onclick="playAllTeleprompters()" class="success-btn">‚ñ∂Ô∏è Resume All Teleprompters</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  
  <!-- End Right Sidebar -->

  </div> <!-- End Page Layout -->

  <script>
    // --- Global Variables ---
    const ws = new WebSocket("ws://" + window.location.host);
    const consoleOutput = document.getElementById("console-output");
    let voiceBypassEnabled = true;
    let lastAudioRecording = null;

    // --- WebSocket Handlers ---
    ws.onopen = function () {
      console.log("WebSocket connection established");
      logToConsole("WebSocket connected", "info");
      fetch("/getVoiceBypass")
        .then((res) => res.json())
        .then((data) => {
          voiceBypassEnabled = data.enabled;
          updateVoiceBypassButton();
        })
        .catch((err) => {
          console.error("Error fetching voice bypass state:", err);
          logToConsole("Error fetching voice bypass state", "error");
        });
    };

    ws.onerror = function (error) {
      console.error("WebSocket error:", error);
      logToConsole("WebSocket error: " + (error.message || "Unknown error"), "error");
    };

    ws.onclose = function () {
      console.log("WebSocket connection closed");
      logToConsole("WebSocket connection closed", "warn");
    };

    ws.onmessage = function (event) {
      try {
        const data = JSON.parse(event.data);
        console.log('Message from server:', data);

        switch (data.type) {
          case 'CONSOLE':
            logToConsole(data.message, data.level);
            break;
          case 'SESSION_UPDATE':
            updateSessionUI(data.sessionId);
            break;
          case 'ACTORS_CALLED':
            document.getElementById("actorsReadyBtn").style.display = "inline-block";
            document.getElementById("actionBtn").style.display = "none"; // Hide action btn
            document.getElementById("status").innerText = "Waiting for actors to be ready...";
            break;
          case 'ACTORS_READY':
            document.getElementById("actorsReadyBtn").style.display = "none";
            document.getElementById("actionBtn").style.display = "inline-block";
            document.getElementById("status").innerText = "Actors are ready to perform!";
            break;
          // Add other message types handled by the server if needed
          default:
            console.log("Received unhandled message type:", data.type);
        }
      } catch (error) {
        console.error('Error parsing message or handling update:', error);
        logToConsole('Received non-JSON message or error handling update.', 'error');
      }
    };

    // --- UI Update Functions ---
    function updateSessionUI(newSessionId) {
      const currentSessionSpan = document.getElementById('current-session-id');
      if (currentSessionSpan) {
        currentSessionSpan.textContent = newSessionId;
      }
      document.querySelectorAll('.session-item').forEach(item => {
        const button = item.querySelector('.session-button');
        const deleteButton = item.querySelector('.delete-session-button');
        const sessionInButton = button?.getAttribute('onclick')?.match(/selectSession\('(.*?)'\)/)?.[1];

        if (button && sessionInButton) {
          if (sessionInButton === newSessionId) {
            button.classList.add('active');
            if (deleteButton) deleteButton.style.display = 'none';
          } else {
            button.classList.remove('active');
            if (deleteButton) deleteButton.style.display = '';
          }
        }
      });
      logToConsole(`Session updated to: ${newSessionId}`, 'info');
    }

    function updateVoiceBypassButton() {
      const btn = document.getElementById("voiceBypassBtn");
      if (btn) {
        btn.textContent = voiceBypassEnabled ? "Disable Voice Bypass" : "Enable Voice Bypass";
        btn.style.backgroundColor = voiceBypassEnabled ? "#ff4444" : "#4CAF50";
      }
    }

    // --- Logging Function ---
    function logToConsole(message, level = 'info') {
      const entry = document.createElement('div');
      const timestamp = new Date().toLocaleTimeString();
      entry.className = `log-entry log-${level}`;
      entry.innerHTML = `<span class="timestamp">[${timestamp}]</span> ${message}`;
      if (consoleOutput) {
        consoleOutput.appendChild(entry);
        consoleOutput.scrollTop = consoleOutput.scrollHeight;
      } else {
        console.error("Console output element (#console-output) not found!");
      }
    }

    // --- Session Management Functions ---
    async function selectSession(sessionId) {
      logToConsole(`Attempting to switch to session: ${sessionId}`, 'info');
      try {
        const response = await fetch('/api/select-session', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: `sessionId=${encodeURIComponent(sessionId)}`
        });
        const result = await response.json();
        if (!response.ok) {
          throw new Error(result.message || result.error || `HTTP error ${response.status}`);
        }
        logToConsole(`Successfully requested switch to session: ${sessionId}`, 'success');
        // UI update is handled by the SESSION_UPDATE broadcast message from the server
      } catch (error) {
        console.error('Error selecting session:', error);
        logToConsole(`Error selecting session: ${error.message}`, 'error');
      }
    }

    async function deleteSession(sessionId) {
      if (!confirm(`Are you sure you want to permanently delete session ${sessionId} and all its recordings?`)) {
        return;
      }
      logToConsole(`Attempting to delete session: ${sessionId}`, 'warn');
      try {
        const response = await fetch(`/api/sessions/${encodeURIComponent(sessionId)}`, {
          method: 'DELETE'
        });
        const result = await response.json();
        if (!response.ok) {
          throw new Error(result.message || result.error || `HTTP error ${response.status}`);
        }
        logToConsole(`Successfully deleted session: ${sessionId}`, 'success');
        // Remove the session item from the UI
        const sessionList = document.getElementById('existing-sessions-list');
        const itemToRemove = sessionList.querySelector(`.session-item button[onclick*="${sessionId}"]`)?.closest('.session-item');
        if (itemToRemove) {
          itemToRemove.remove();
        }
        if (!sessionList.querySelector('.session-item')) {
          sessionList.innerHTML = '<p>No other sessions found.</p>';
        }
      } catch (error) {
        console.error('Error deleting session:', error);
        logToConsole(`Error deleting session ${sessionId}: ${error.message}`, 'error');
      }
    }

    // --- Control Button Functions ---
    function toggleVoiceBypass() {
      const newState = !voiceBypassEnabled;
      fetch("/setVoiceBypass", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ enabled: newState }),
      })
        .then(res => res.ok ? res.json() : res.text().then(text => Promise.reject(text || res.statusText)))
        .then(info => {
          voiceBypassEnabled = newState; // Update state only on success
          updateVoiceBypassButton();
          document.getElementById("status").innerText = info.message;
          logToConsole(`Voice Bypass ${newState ? 'enabled' : 'disabled'}.`, 'info');
        })
        .catch(err => {
          console.error("Set Bypass Error:", err);
          document.getElementById("status").innerText = "Error setting bypass: " + err;
          logToConsole(`Error setting bypass: ${err}`, 'error');
          // Don't change UI state if request failed
        });
    }

    function openTeleprompter() {
      window.open("/teleprompter", "teleprompter", "width=800,height=600");
    }

    function openCharacterTeleprompter(character) {
      window.open(`/teleprompter/${character}`, `teleprompter-${character}`, "width=800,height=600");
    }

    function testTeleprompter() {
      logToConsole("Testing teleprompter message...", 'info');
      // Example actor ID - replace if needed
      const exampleActorId = "Alan-Grant-A1B2C3";
      const headshotPath = `/database/actors/${exampleActorId}/headshot.jpg`;
      fetch("/teleprompter/updateTeleprompter", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text: "Test message with image", image: headshotPath }),
      })
        .then(res => { if (!res.ok) logToConsole(`Test Teleprompter Error (1): ${res.statusText}`, 'error'); })
        .catch(err => logToConsole(`Test Teleprompter Error (1): ${err}`, 'error'));
      setTimeout(() => {
        fetch("/teleprompter/updateTeleprompter", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text: "Test message without image" }),
        })
          .then(res => { if (!res.ok) logToConsole(`Test Teleprompter Error (2): ${res.statusText}`, 'error'); })
          .catch(err => logToConsole(`Test Teleprompter Error (2): ${err}`, 'error'));
      }, 3000);
    }

    function testTeleprompterVideo() {
      logToConsole("Testing teleprompter video...", 'info');
      const exampleVideoPath = "/database/test_content/freefall.mp4"; // Check path
      fetch("/teleprompter/playTeleprompterVideo", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ videoPath: exampleVideoPath }),
      })
        .then(res => { if (!res.ok) logToConsole(`Test Teleprompter Video Error: ${res.statusText}`, 'error'); })
        .catch(err => logToConsole(`Test Teleprompter Video Error: ${err}`, 'error'));
    }

    function clearTeleprompter() {
      logToConsole("Clearing teleprompter...", 'info');
      fetch("/teleprompter/clearTeleprompter", { method: "POST" })
        .then(res => res.ok ? res.json() : res.text().then(text => Promise.reject(text || res.statusText)))
        .then(info => {
          document.getElementById("status").innerText = info.message;
          logToConsole("Teleprompter cleared.", 'info');
        })
        .catch(err => {
          console.error("Clear Teleprompter Error:", err);
          document.getElementById("status").innerText = "Error clearing teleprompter: " + err;
          logToConsole(`Error clearing teleprompter: ${err}`, 'error');
        });
    }

    function initScene(directory) {
      logToConsole(`Requesting scene init: ${decodeURIComponent(directory)}`, 'info');
      document.getElementById("status").innerText = `Initializing ${decodeURIComponent(directory)}...`;
      fetch("/initScene/" + encodeURIComponent(directory))
        .then(res => res.ok ? res.json() : res.text().then(text => Promise.reject(text || res.statusText)))
        .then(info => {
          document.getElementById("status").innerText = info.message;
          logToConsole(`Scene init request sent for ${info.directory}.`, 'success');
        })
        .catch(err => {
          console.error("Init Scene Error:", err);
          document.getElementById("status").innerText = "Error initializing scene: " + err;
          logToConsole(`Error initializing scene ${decodeURIComponent(directory)}: ${err}`, 'error');
        });
    }

    function actorsReady() {
      logToConsole("Sending Actors Ready signal...", 'info');
      document.getElementById("status").innerText = "Notifying system: actors ready...";
      fetch("/actorsReady", { method: "POST" })
        .then(res => res.ok ? res.json() : res.text().then(text => Promise.reject(text || res.statusText)))
        .then(info => {
          document.getElementById("status").innerText = info.message;
          logToConsole("Actors Ready signal sent.", 'success');
        })
        .catch(err => {
          console.error("Actors Ready Error:", err);
          document.getElementById("status").innerText = "Error sending Actors Ready: " + err;
          logToConsole(`Error sending Actors Ready: ${err}`, 'error');
        });
    }

    function handlePipelineChange(pipeline) {
      logToConsole(`Recording pipeline set to: ${pipeline}`, "info");
      // If pipeline choice needs to be sent to server, do it here.
    }

    async function recordVideo() {
      // This button triggers the test recording route for a specific camera
      // Requires camera selection UI element to be implemented for proper use
      const selectedCameraName = "Camera 1"; // Placeholder - NEEDS UI element to select camera
      document.getElementById("status").innerText = `Recording TEST video from ${selectedCameraName}...`;
      const pipeline = document.getElementById("recording-pipeline").value;
      const useFfmpeg = pipeline === "ffmpeg";
      const resolution = document.getElementById("recording-resolution").value;
      logToConsole(`Starting TEST recording for ${selectedCameraName} with ${pipeline} pipeline at ${resolution}`, "info");
      try {
        const response = await fetch(`/camera/${encodeURIComponent(selectedCameraName)}/record?useFfmpeg=${useFfmpeg}&resolution=${resolution}`, { method: 'POST' });
        const result = await response.json();
        if (!response.ok) {
          throw new Error(result.message || result.error || `HTTP error ${response.status}`);
        }
        logToConsole(`Test recording successful for ${selectedCameraName}. Output: ${result.overlayName}`, 'success');
        document.getElementById("status").innerText = `Test recording finished: ${result.overlayName}`;
        // Optionally display video in #videos div?
        // const vidDiv = document.getElementById("videos");
        // const session = document.getElementById('current-session-id')?.textContent;
        // if(vidDiv && session && result.overlayName) {
        //     vidDiv.innerHTML = `<h3>Test Overlay Video (${selectedCameraName})</h3><video controls src="/recordings/${session}/${result.overlayName}"></video>`;
        // }
      } catch (error) {
        logToConsole(`Test recording error for ${selectedCameraName}: ${error.message}`, "error");
        document.getElementById("status").innerText = `Test recording failed: ${error.message}`;
      }
    }

    function action() {
      logToConsole("Sending Action signal...", 'info');
      document.getElementById("status").innerText = "Starting action...";
      fetch("/action", { method: "POST" })
        .then(res => res.ok ? res.json() : res.text().then(text => Promise.reject(text || res.statusText)))
        .then(info => {
          document.getElementById("status").innerText = info.message;
          logToConsole("Action signal sent.", 'success');
        })
        .catch(err => {
          console.error("Action Error:", err);
          document.getElementById("status").innerText = "Error sending Action: " + err;
          logToConsole(`Error sending Action: ${err}`, 'error');
        });
    }

    function testConsole() {
      fetch("/testConsole", { method: "POST" })
        .then(res => res.ok ? res.json() : res.text().then(text => Promise.reject(text || res.statusText)))
        .then(info => { document.getElementById("status").innerText = info.message; })
        .catch(err => {
          console.error("Test Console Error:", err);
          document.getElementById("status").innerText = "Error testing console: " + err;
        });
    }

    function pauseAllTeleprompters() {
      ws.send(JSON.stringify({ type: "TELEPROMPTER_CONTROL", action: "PAUSE" }));
      logToConsole("Paused all teleprompters", "info");
    }

    function playAllTeleprompters() {
      ws.send(JSON.stringify({ type: "TELEPROMPTER_CONTROL", action: "PLAY" }));
      logToConsole("Resumed all teleprompters", "info");
    }

    // --- Audio Functions ---
    function testAudioRecord() {
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then((stream) => {
          const mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm" });
          const audioChunks = [];
          mediaRecorder.ondataavailable = (e) => { audioChunks.push(e.data); };
          mediaRecorder.onstop = async () => {
            const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
            const formData = new FormData();
            // Use a timestamp in the filename for uniqueness in temp dir
            formData.append("audio", audioBlob, `rec_${Date.now()}.webm`);
            logToConsole("Sending audio data to server...", 'info');
            try {
              const response = await fetch("/recordAudio", { method: "POST", body: formData });
              const data = await response.json();
              if (!response.ok) {
                throw new Error(data.message || `HTTP error ${response.status}`);
              }
              logToConsole(`Audio recorded: ${data.filename}`, "info");
              lastAudioRecording = data.filename; // Store relative filename from session dir
            } catch (err) {
              logToConsole(`Error recording audio: ${err.message}`, "error");
            }
          };
          mediaRecorder.start();
          logToConsole("Recording audio for 5 seconds...", "info");
          setTimeout(() => {
            try {
              if (mediaRecorder.state === "recording") {
                mediaRecorder.stop();
              }
              stream.getTracks().forEach((track) => track.stop()); // Stop microphone access
            } catch (e) { console.error("Error stopping recorder/stream:", e); }
          }, 5000);
        })
        .catch((err) => logToConsole(`Error accessing microphone: ${err.message}`, "error"));
    }

    function playLastRecording() {
      if (!lastAudioRecording) {
        logToConsole("No audio recording available to play", "warn");
        return;
      }
      const currentSessionId = document.getElementById('current-session-id')?.textContent;
      if (!currentSessionId) {
        logToConsole("Cannot determine current session ID to play audio.", "error");
        return;
      }
      // Assumes Express serves /recordings static path
      const audioUrl = `/recordings/${currentSessionId}/${lastAudioRecording}`;
      logToConsole(`Attempting to play: ${audioUrl}`, 'info');
      const audio = new Audio(audioUrl);
      audio.onerror = (e) => {
        console.error("Audio playback error:", e);
        logToConsole(`Error playing audio from ${audioUrl}. Check server serves /recordings or if file exists.`, "error");
      };
      audio.play()
        .then(() => logToConsole(`Playing ${lastAudioRecording}...`, "info"))
        .catch((err) => logToConsole(`Error initiating audio playback: ${err.message}`, "error"));
    }

    function clearAudio() {
      if (!lastAudioRecording) {
        logToConsole("No audio recording available to clear", "warn");
        return;
      }
      logToConsole("Clear Audio button needs server-side endpoint (e.g., DELETE /api/sessions/:id/audio/:filename).", "warn");
      // Example client-side removal (doesn't delete server file):
      // lastAudioRecording = null;
      // logToConsole("Cleared last audio recording reference (client-side only).", "info");
    }

    // --- Actor Loading Logic ---
    const loadActorsBtn = document.getElementById('loadActorsBtn');
    const actorFilesInput = document.getElementById('actorFiles');
    const loadActorsStatus = document.getElementById('loadActorsStatus');
    if (loadActorsBtn && actorFilesInput && loadActorsStatus) {
      loadActorsBtn.addEventListener('click', async () => {
        const files = actorFilesInput.files;
        if (!files || files.length === 0) { // Check if files is null or empty
          loadActorsStatus.textContent = 'Please select files to load.';
          loadActorsStatus.className = 'status-error'; return;
        }
        const formData = new FormData();
        for (const file of files) { formData.append('files', file); }
        loadActorsStatus.textContent = 'Loading...';
        loadActorsStatus.className = 'status-info';
        try {
          const response = await fetch('/loadActors', { method: 'POST', body: formData });
          const result = await response.json();
          if (!response.ok) {
            throw new Error(result.message || `HTTP error ${response.status}`);
          }
          loadActorsStatus.textContent = result.message || 'Actors loaded!';
          loadActorsStatus.className = 'status-success';
          actorFilesInput.value = ''; // Clear file input
        } catch (error) {
          console.error("Actor Load Error:", error);
          loadActorsStatus.textContent = `Error: ${error.message}`;
          loadActorsStatus.className = 'status-error';
        }
      });
    }

    // --- Camera Manager ---
    class CameraManager {
      constructor() {
        this.cameras = [];
        this.cameraElements = new Map();
        this.availableDevices = []; // Browser devices { deviceId, label, kind, groupId }
        this.ptzDevices = [];
        this.serverDevices = []; // Server devices { id, name }
        this.cameraDefaults = [];
      }

      async initialize() {
        try {
          // --- Get Browser Devices and Request Permissions FIRST ---
          logToConsole("Attempting to enumerate browser devices...", "info");
          let browserDevicesRaw = await navigator.mediaDevices.enumerateDevices();
          this.availableDevices = browserDevicesRaw.filter(
            (device) => device.kind === "videoinput"
          );
          logToConsole(`Initial browser devices found: ${this.availableDevices.length}`, "info");
          if (this.availableDevices.length > 0) {
            const labelsMissing = !this.availableDevices[0].label;
            const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
            if (labelsMissing || isMac) {
              logToConsole("Labels missing or on macOS, requesting camera access for labels...", "info");
              try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                stream.getTracks().forEach((track) => track.stop());
                browserDevicesRaw = await navigator.mediaDevices.enumerateDevices();
                this.availableDevices = browserDevicesRaw.filter(device => device.kind === "videoinput");
                logToConsole(`Browser devices after requesting permission: ${this.availableDevices.length}`, "info");
              } catch (err) {
                logToConsole(`Error requesting camera permission: ${err.message}`, "error");
              }
            }
          }

          // --- Get Server Configuration & Devices ---
          logToConsole("Fetching server configuration and devices...", "info");
          const camerasResponse = await fetch("/camera/cameras");
          if (!camerasResponse.ok) throw new Error(`HTTP error! status: ${camerasResponse.status}`);
          this.cameras = await camerasResponse.json();

          const configResponse = await fetch("/config");
          if (!configResponse.ok) throw new Error(`HTTP error! status: ${configResponse.status}`);
          const config = await configResponse.json();
          this.cameraDefaults = config.cameraDefaults || [];

          const devicesResponse = await fetch("/camera/devices");
          if (!devicesResponse.ok) throw new Error(`HTTP error! status: ${devicesResponse.status}`);
          this.serverDevices = await devicesResponse.json(); // Still need server devices for Recording dropdown
          logToConsole(`Server reported ${this.serverDevices.length} devices`, "info");

          // --- Get PTZ Devices ---
          if (this.cameras.length > 0) {
            logToConsole("Fetching PTZ devices...", "info");
            try {
              const ptzResponse = await fetch("/camera/ptz-devices");
              if (ptzResponse.ok) {
                this.ptzDevices = await ptzResponse.json();
                logToConsole(`Found ${this.ptzDevices.length} PTZ devices`, "info");
              }
            } catch (ptzError) {
              this.ptzDevices = [];
              logToConsole(`Error fetching PTZ devices: ${ptzError.message}`, "error");
            }
          } else {
            this.ptzDevices = [];
          }

          this.renderCameraControls();
          logToConsole(`Camera manager initialized with ${this.cameras.length} cameras`, "success");

        } catch (err) {
          logToConsole(`Error initializing camera manager: ${err.message}`, "error");
        }
      }

      async addCamera() {
        const cameraIndex = this.cameras.length;
        const name = `Camera_${cameraIndex + 1}`;

        // Get the defaults for this camera index, or use empty defaults if none exist
        const defaults = this.cameraDefaults[cameraIndex] || {
          previewDevice: "",
          recordingDevice: "",
          ptzDevice: "",
        };

        try {
          logToConsole(`Adding new camera: ${name}...`, "info");
          const response = await fetch("/camera/add", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              name,
              previewDevice: defaults.previewDevice,
              recordingDevice: defaults.recordingDevice,
              ptzDevice: defaults.ptzDevice,
            }),
          });

          if (response.ok) {
            logToConsole(`Camera ${name} added successfully`, "success");
            await this.initialize(); // Refresh the camera list
          } else {
            const error = await response.json();
            throw new Error(error.message || `HTTP error ${response.status}`);
          }
        } catch (err) {
          logToConsole(`Error adding camera: ${err.message}`, "error");
        }
      }

      async removeCamera(name) {
        if (!confirm(`Are you sure you want to remove camera '${name}'?`)) {
          return;
        }

        try {
          logToConsole(`Removing camera: ${name}...`, "warn");
          const response = await fetch("/camera/remove", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ name }),
          });

          if (response.ok) {
            logToConsole(`Camera ${name} removed successfully`, "success");
            await this.initialize(); // Refresh the camera list
          } else {
            const error = await response.json();
            throw new Error(error.message || `HTTP error ${response.status}`);
          }
        } catch (err) {
          logToConsole(`Error removing camera: ${err.message}`, "error");
        }
      }

      renderCameraControls() {
        const container = document.getElementById("cameraControls");
        container.innerHTML = "";
        this.cameraElements.clear(); // Clear the map before re-rendering

        if (this.cameras.length === 0) {
          container.innerHTML = '<p>No cameras configured. Click "Add Camera" to set up a camera.</p>';
          return;
        }

        // --- Render controls for each camera ---
        this.cameras.forEach((camera) => {
          const cameraElement = this.createCameraElement(camera);
          container.appendChild(cameraElement);
          this.cameraElements.set(camera.name, cameraElement); // Store element reference
        });

        // --- NEW: Initial render of PTZ controls AFTER elements are in DOM ---
        this.cameras.forEach((camera) => {
          if (camera.ptzDevice) {
             // Check if the element exists before rendering
             const cameraElement = this.cameraElements.get(camera.name);
             if (cameraElement && container.contains(cameraElement)) {
               this.renderPTZControlsForCamera(camera.name, camera.ptzDevice);
             } else {
               console.warn(`Camera element for ${camera.name} not found in DOM for initial PTZ render.`);
             }
          }
        });
        // --- END NEW ---
      }

      createCameraElement(camera) {
        const div = document.createElement("div");
        div.className = "camera-control";

        // --- Determine Preview Display Label & Initial ID --- 
        let currentPreviewDisplayLabel = "No device selected";
        const currentPreviewBrowserId = camera.previewDevice;
        let initialPreviewCallNeeded = false;

        if (currentPreviewBrowserId) {
          const browserDevice = this.availableDevices.find(d => d.deviceId === currentPreviewBrowserId);
          if (browserDevice) {
            currentPreviewDisplayLabel = browserDevice.label || currentPreviewBrowserId;
            initialPreviewCallNeeded = true; // We have a valid browser ID to init with
          } else {
            currentPreviewDisplayLabel = `Saved ID not found: ${currentPreviewBrowserId}`;
          }
        }

        div.innerHTML = `
            <div class="camera-header">
              <h3>${camera.name.replace(/_/g, ' ')}</h3>
              <button onclick="cameraManager.removeCamera('${camera.name}')" class="remove-btn" title="Remove ${camera.name}">‚ùå</button>
            </div>
            <div class="camera-preview">
              <video id="preview-${camera.name}" autoplay playsinline></video>
              <div class="device-info">Using: ${currentPreviewDisplayLabel}</div>
            </div>
            <div class="camera-settings">
              <div class="setting-group">
                <label>Preview Device:</label>
                <select class="preview-device" onchange="cameraManager.updatePreviewDevice('${camera.name}', this.value)">
                  <option value="">Select Preview Device</option>
                  ${this.availableDevices
            .map((browserDevice) => {
              // Attempt to find the corresponding server device to get the path
              // This relies on the browser label matching the start of the server name (e.g., "Integrated Camera" matching "Integrated Camera (/dev/video0)")
              const serverDevice = this.serverDevices.find(sd => sd.name?.startsWith(browserDevice.label));
              const displayLabel = serverDevice 
                ? `${browserDevice.label} (${serverDevice.id})` // Use label and server path (which is the id)
                : (browserDevice.label || browserDevice.deviceId); // Fallback if no match found

              return `
                <option value="${browserDevice.deviceId}" ${
                  // Select based on current browser ID saved in camera config
                  browserDevice.deviceId === currentPreviewBrowserId ? "selected" : ""
                }>
                  ${displayLabel} 
                </option>
              `;
            })
            .join("")}
                </select>
              </div>
              <div class="setting-group">
                <label>Recording Device:</label>
                 <select class="recording-device" 
                   onchange="logToConsole('Recording Device changed to: ' + this.value, 'info'); cameraManager.updateRecordingDevice('${camera.name}', this.value)">
                  <option value="">Select Recording Device</option>
                  ${this.serverDevices
            .map(
              (serverDevice) => `
                           <option value="${serverDevice.id}" ${serverDevice.id === camera.recordingDevice ? "selected" : ""
                }>
                              ${serverDevice.name || serverDevice.id}
                           </option>
                         `
            )
            .join("")}
                </select>
              </div>
              <div class="setting-group">
                <label>PTZ Device:</label>
                <select class="ptz-device" onchange="cameraManager.updatePTZDevice('${camera.name}', this.value)">
                   <option value="">Select PTZ Device</option> 
                   ${this.ptzDevices
            .map(
              (device) => `
                     <option value="${device.id || device.path}" ${(device.id || device.path) === camera.ptzDevice ? "selected" : ""
                }>
                       ${device.name || device.id || device.path}
                     </option>
                   `
            )
            .join("")}
                </select>
              </div>
              <div class="ptz-controls-container">
                <!-- PTZ controls will be added here if a PTZ device is selected -->
              </div>
              <div class="camera-controls">
                <button onclick="cameraManager.recordVideo('${camera.name}')">Test Record Video (${camera.name.replace(/_/g, ' ')})</button>
              </div>
            </div>
          `;

        // Initialize preview if we have a valid browser ID from config
        if (initialPreviewCallNeeded) {
          logToConsole(`Initializing preview for ${camera.name} using browserId: ${currentPreviewBrowserId}`, "info");
          setTimeout(() => {
            this.updatePreviewDevice(camera.name, currentPreviewBrowserId);
          }, 100);
        }

        return div;
      }

      async updatePreviewDevice(cameraName, browserDeviceId) {
        logToConsole(`Updating preview device for ${cameraName} with browser device ID: ${browserDeviceId}`, "info");
        try {
          // Update server - send browserDeviceId 
          await fetch("/camera/preview-device", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ cameraName, deviceId: browserDeviceId }),
          });

          const videoElement = document.getElementById(`preview-${cameraName}`);
          if (!videoElement) {
            logToConsole(`Video element for ${cameraName} not found`, "error");
            return;
          }

          // Stop any existing stream
          if (videoElement.srcObject) {
            const tracks = videoElement.srcObject.getTracks();
            tracks.forEach(track => track.stop());
            videoElement.srcObject = null;
          }

          // Use browserDeviceId directly for getUserMedia
          if (browserDeviceId) {
            try {
              const stream = await navigator.mediaDevices.getUserMedia({
                video: { deviceId: { exact: browserDeviceId } }
              });
              videoElement.srcObject = stream;

              const browserDevice = this.availableDevices.find(d => d.deviceId === browserDeviceId);
              const displayLabel = browserDevice ? (browserDevice.label || browserDeviceId) : 'Unknown';
              const deviceInfoElement = videoElement.nextElementSibling;
              if (deviceInfoElement) {
                deviceInfoElement.textContent = `Using: ${displayLabel}`;
              }
              logToConsole(`Preview for ${cameraName} started with device: ${displayLabel}`, "success");
            } catch (err) {
              logToConsole(`Error starting camera preview: ${err.message}`, "error");
            }
          } else {
            // No device selected, just update the info text
            const deviceInfoElement = videoElement.nextElementSibling;
            if (deviceInfoElement) {
              deviceInfoElement.textContent = "No device selected";
            }
          }
        } catch (err) {
          logToConsole(`Error updating preview device: ${err.message}`, "error");
        }
      }

      async updateRecordingDevice(cameraName, serverDeviceId) {
        logToConsole(`Setting recording device for ${cameraName} with server device ID: ${serverDeviceId}`, "info");
        try {
          const response = await fetch("/camera/recording-device", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ cameraName, deviceId: serverDeviceId }),
          });

          if (!response.ok) {
            const errorText = await response.text();
            logToConsole(`Error setting recording device: ${errorText}`, "error");
            throw new Error(`Server error: ${response.status}`);
          }

          const responseData = await response.json();
          logToConsole(`Recording device set for ${cameraName}`, "success");
        } catch (err) {
          logToConsole(`Error updating recording device: ${err.message}`, "error");
        }
      }

      async updatePTZDevice(cameraName, serverDeviceId) {
        logToConsole(`Setting PTZ device for ${cameraName} with server device ID: ${serverDeviceId}`, "info");
        try {
          const response = await fetch("/camera/ptz-device", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ cameraName, deviceId: serverDeviceId }),
          });

          if (!response.ok) {
            const errorText = await response.text();
            logToConsole(`Error setting PTZ device: ${errorText}`, "error");
            throw new Error(`Server error: ${response.status}`);
          }

          const responseData = await response.json();
          logToConsole(`PTZ device set for ${cameraName}`, "success");

          // --- NEW: Render PTZ controls after setting a device ---
          this.renderPTZControlsForCamera(cameraName, serverDeviceId);
          // --- END NEW ---

        } catch (err) {
          logToConsole(`Error updating PTZ device: ${err.message}`, "error");
        }
      }

      // --- NEW: Function to render PTZ controls for a specific camera ---
      renderPTZControlsForCamera(cameraName, ptzDeviceId) {
        const cameraElement = this.cameraElements.get(cameraName);
        if (!cameraElement) return;

        const ptzContainer = cameraElement.querySelector('.ptz-controls-container');
        if (!ptzContainer) return;

        // Clear previous controls
        ptzContainer.innerHTML = '';

        // Only render controls if a valid PTZ device is selected
        if (ptzDeviceId) {
          // Use unique IDs per camera instance
          const panId = `ptz-pan-${cameraName}`;
          const tiltId = `ptz-tilt-${cameraName}`;
          const zoomId = `ptz-zoom-${cameraName}`;
          const panValueId = `ptz-pan-value-${cameraName}`;
          const tiltValueId = `ptz-tilt-value-${cameraName}`;
          const zoomValueId = `ptz-zoom-value-${cameraName}`;

          ptzContainer.innerHTML = `
            <div class=\"ptz-control-group\">
              <label for=\"${panId}\">Pan:</label>
              <input type=\"range\" id=\"${panId}\" name=\"pan\" min=\"-468000\" max=\"468000\" step=\"3600\" value=\"0\" 
                     oninput=\"cameraManager.handlePTZInputChange(\'${cameraName}\', \'pan\', this.value)\"
                     title=\"Pan\">
              <span id=\"${panValueId}\" class=\"ptz-value-display\">0.0¬∞</span> 
            </div>
            <div class=\"ptz-control-group\">
              <label for=\"${tiltId}\">Tilt:</label>
              <input type=\"range\" id=\"${tiltId}\" name=\"tilt\" min=\"-324000\" max=\"324000\" step=\"3600\" value=\"0\"
                     oninput=\"cameraManager.handlePTZInputChange(\'${cameraName}\', \'tilt\', this.value)\"
                     title=\"Tilt\">
              <span id=\"${tiltValueId}\" class=\"ptz-value-display\">0.0¬∞</span> 
            </div>
            <div class=\"ptz-control-group\">
              <label for=\"${zoomId}\">Zoom:</label>
              <input type=\"range\" id=\"${zoomId}\" name=\"zoom\" min=\"0\" max=\"100\" step=\"1\" value=\"0\"
                     oninput=\"cameraManager.handlePTZInputChange(\'${cameraName}\', \'zoom\', this.value)\"
                     title=\"Zoom\">
              <span id=\"${zoomValueId}\" class=\"ptz-value-display\">0%</span> 
            </div>
          `;
        } else {
          ptzContainer.innerHTML = '<p class=\"ptz-placeholder\">Select a PTZ device to enable controls.</p>';
        }
      }

      // --- NEW: Handler for PTZ slider input changes ---
      handlePTZInputChange(cameraName, control, value) {
        const rawValue = parseInt(value);
        let displayValue = '';
        let displaySpanId = '';

        // Update display span based on control type
        switch (control) {
          case 'pan':
            displayValue = (rawValue / 3600).toFixed(1) + '¬∞';
            displaySpanId = `ptz-pan-value-${cameraName}`;
            break;
          case 'tilt':
            displayValue = (rawValue / 3600).toFixed(1) + '¬∞';
            displaySpanId = `ptz-tilt-value-${cameraName}`;
            break;
          case 'zoom':
            displayValue = rawValue + '%';
            displaySpanId = `ptz-zoom-value-${cameraName}`;
            break;
        }

        const displaySpan = document.getElementById(displaySpanId);
        if (displaySpan) {
          displaySpan.textContent = displayValue;
        }

        // Call the existing method to send data to the server
        this.updatePTZ(cameraName, control, rawValue);
      }
      // --- END NEW ---

      // Existing method to send PTZ command to server
      async updatePTZ(cameraName, control, value) {
        try {
          await fetch("/camera/ptz", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              cameraName,
              [control]: parseInt(value)
            }),
          });
        } catch (err) {
          logToConsole(`Error updating PTZ controls: ${err.message}`, "error");
        }
      }

      async recordVideo(cameraName) {
        logToConsole(`Starting recording for ${cameraName}...`, "info");
        document.getElementById("status").innerText = `Recording from ${cameraName}...`;

        const pipeline = document.getElementById("recording-pipeline").value;
        const useFfmpeg = pipeline === "ffmpeg";
        const resolution = document.getElementById("recording-resolution").value;

        try {
          const response = await fetch(
            `/camera/${encodeURIComponent(cameraName)}/record?useFfmpeg=${useFfmpeg}&resolution=${resolution}`,
            { method: "POST" }
          );

          if (!response.ok) {
            const errorText = await response.text(); // Get error details
            throw new Error(`HTTP error ${response.status}: ${errorText}`);
          }

          const result = await response.json();
          logToConsole(`Recording complete for ${cameraName}. Output: ${result.overlayName}`, "success");
          document.getElementById("status").innerText = `Recording finished: ${result.overlayName}`;

          // Construct correct video path using current session ID
          const sessionIdElement = document.getElementById('current-session-id');
          const currentSessionId = sessionIdElement ? sessionIdElement.textContent.trim() : null; // TRIM the whitespace

          const vidDiv = document.getElementById("videos");

          if (vidDiv && currentSessionId && result.overlayName) {
            const videoPath = `/recordings/${encodeURIComponent(currentSessionId)}/${encodeURIComponent(result.overlayName)}`;
            logToConsole(`Displaying video: ${videoPath}`, "info");
            vidDiv.innerHTML = `
              <h3>Overlay Video (${cameraName.replace(/_/g, ' ')})</h3>
              <video controls src="${videoPath}"></video>
            `;
          } else if (!currentSessionId) {
            logToConsole("Could not find current session ID to display video", "error");
          }
        } catch (error) {
          logToConsole(`Recording error: ${error.message}`, "error");
          document.getElementById("status").innerText = `Recording failed: ${error.message}`;
        }
      }
    }

    const cameraManager = new CameraManager();
    window.addEventListener("load", async () => {
      logToConsole("Window loaded. Initializing components...", "info");
      if (cameraManager.initialize) {
        try {
          await cameraManager.initialize();
        } catch (err) {
          logToConsole(`CameraManager initialization failed: ${err}`, 'error');
        }
      }
    });

    // --- Resizer Logic (Simplified Flexbox Approach) --- 
    function initializeResizers() {
      const leftSidebar = document.querySelector('.left-sidebar');
      const mainContent = document.querySelector('.main-content');
      const rightSidebar = document.querySelector('.sidebar');
      const resizerLeftMain = document.getElementById('resizer-left-main');
      const resizerMainRight = document.getElementById('resizer-main-right');

      let isResizing = false;
      let startX, initialLeftBasis, initialRightBasis;
      let currentResizer = null;
      let initialMainContentWidth = 0; // Store main content width for right handle

      // Helper to get computed basis or width
      const getBasis = (el) => {
        const basis = getComputedStyle(el).flexBasis;
        // If basis is 'auto', 'content', or not in pixels, use offsetWidth as fallback
        if (basis === 'auto' || basis === 'content' || !basis.endsWith('px')) {
          console.warn('getBasis falling back to offsetWidth for element:', el, 'Computed flex-basis was:', basis);
          return el.offsetWidth;
        }
        return parseInt(basis, 10);
      };

      const startResize = (e, resizer) => {
        isResizing = true;
        currentResizer = resizer;
        startX = e.clientX;

        // Get initial basis values
        initialLeftBasis = getBasis(leftSidebar);
        initialRightBasis = getBasis(rightSidebar);
        initialMainContentWidth = mainContent.offsetWidth; // Get main content width

        document.body.style.userSelect = 'none';
        document.body.style.pointerEvents = 'none';
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', stopResize);
      };

      const handleMouseMove = (e) => {
        if (!isResizing) return;

        const currentX = e.clientX;
        const dx = currentX - startX;

        const minLeftWidth = parseInt(getComputedStyle(leftSidebar).minWidth, 10);
        const minRightWidth = parseInt(getComputedStyle(rightSidebar).minWidth, 10);
        const minMainWidth = parseInt(getComputedStyle(mainContent).minWidth, 10);

        if (currentResizer === resizerLeftMain) {
          // --- Left handle: Adjust left sidebar width ---
          let newLeftBasis = initialLeftBasis + dx;
          if (newLeftBasis < minLeftWidth) {
            newLeftBasis = minLeftWidth;
          }
          leftSidebar.style.flexBasis = `${newLeftBasis}px`;
          // Let flexbox handle main content width

        } else if (currentResizer === resizerMainRight) {
          // --- Right handle: Adjust main content width instead ---
          // For the right handle, we directly modify the main content's flex-basis
          // This pushes/pulls the right sidebar and should track mouse position 1:1

          // Calculate the new main content width by adding dx (opposite of sidebar calculation)
          let newMainWidth = initialMainContentWidth + dx;

          // Enforce minimum main width
          if (newMainWidth < minMainWidth) {
            newMainWidth = minMainWidth;
          }

          // Apply the new size to the main content
          mainContent.style.flexBasis = `${newMainWidth}px`;
          mainContent.style.flexGrow = '0'; // Temporarily disable flex-grow
        }
      };

      const stopResize = () => {
        if (isResizing) {
          isResizing = false;
          currentResizer = null;
          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', stopResize);

          // Restore user interaction styles
          document.body.style.userSelect = '';
          document.body.style.pointerEvents = '';

          // If we were using the right handle, restore main content's flex-grow
          if (currentResizer === resizerMainRight) {
            mainContent.style.flexGrow = '1';
            mainContent.style.flexBasis = 'auto'; // Reset to auto to let flex-grow work
          }
        }
      };

      resizerLeftMain.addEventListener('mousedown', (e) => startResize(e, resizerLeftMain));
      resizerMainRight.addEventListener('mousedown', (e) => startResize(e, resizerMainRight));
    }

    document.addEventListener('DOMContentLoaded', initializeResizers);

  </script>

  <style>
    /* Add styles for session list */
    .session-list {
      max-height: 150px;
      overflow-y: auto;
      margin-top: 10px;
      border: 1px solid #ddd;
      padding: 5px;
    }

    .session-item {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }

    .session-button {
      flex-grow: 1;
      /* Take available space */
      padding: 8px;
      text-align: left;
      border: 1px solid #ccc;
      background-color: #f9f9f9;
      cursor: pointer;
      box-sizing: border-box;
      white-space: nowrap;
      /* Prevent wrapping */
      overflow: hidden;
      text-overflow: ellipsis;
      min-width: 0;
      /* Prevent flex item from overflowing */
    }

    .delete-session-button {
      width: 28px;
      /* Fixed width */
      height: 28px;
      /* Make it square */
      padding: 0;
      /* Remove padding */
      text-align: center;
      /* Center X */
      margin-left: 5px; /* Add space to the left */
      background-color: #fdd;
      border: 1px solid #f99;
      color: #c00;
      cursor: pointer;
      font-size: 1em;
      /* Adjust if needed */
      line-height: 26px;
      /* Vertical align */
      flex-shrink: 0;
      /* Prevent shrinking */
      border-radius: 3px; /* Restore optional rounding */
    }

    .delete-session-button:hover {
      background-color: #fcc;
      border-color: #f66;
    }

    .log-entry {
      font-family: monospace;
      margin-bottom: 3px;
      white-space: pre-wrap;
      font-size: 0.9em;
    }

    .log-timestamp {
      color: #888;
      margin-right: 5px;
    }

    .log-info {
      color: #333;
    }

    .log-warn {
      color: orange;
    }

    .log-error {
      color: red;
      font-weight: bold;
    }

    .log-success {
      color: green;
    }

    .actor-loading {
      margin-top: 15px;
      padding-top: 10px;
      border-top: 1px dashed #ccc;
    }

    .actor-loading label {
      display: block;
      margin-bottom: 5px;
    }

    .actor-loading input[type="file"] {
      display: block;
      margin-bottom: 10px;
    }

    #loadActorsStatus {
      margin-top: 5px;
      font-style: italic;
    }

    .status-info {
      color: #555;
    }

    .status-success {
      color: green;
    }

    .status-error {
      color: red;
    }

    /* --- ADDED Layout Styles --- */
    body {
      display: flex;
      margin: 0;
      height: 100vh;
      overflow: hidden;
      /* Prevent body scroll */
      /* Add user-select none during resize? Handled by JS */
    }

    .page-layout {
      display: flex;
      width: 100%;
      height: 100%;
      flex-wrap: nowrap;
      /* Explicitly prevent wrapping */
    }

    .left-sidebar {
      flex-basis: 25%;
      /* Changed from 300px to 25% */
      min-width: 150px;
      /* Minimum width - RESTORED */
      padding: 15px;
      border-right: 1px solid #ccc;
      overflow-y: auto;
      background-color: #f8f8f8;
      height: 100%;
      box-sizing: border-box;
      flex-shrink: 0;
      /* Prevent shrinking beyond width */
    }

    .main-content {
      flex-grow: 1;
      /* Takes remaining space */
      flex-basis: 50%;
      /* Explicitly set to 50% instead of relying only on flex-grow */
      min-width: 100px;
      /* Minimum width - RESTORED (was 100px) */
      padding: 15px;
      overflow-y: auto;
      height: 100%;
      box-sizing: border-box;
    }

    .sidebar {
      /* This is the RIGHT sidebar now */
      flex-basis: 25%;
      /* Changed from 300px to 25% */
      min-width: 150px;
      /* Minimum width - RESTORED */
      padding: 15px;
      border-left: 1px solid #ccc;
      overflow-y: auto;
      background-color: #f8f8f8;
      height: 100%;
      box-sizing: border-box;
      flex-shrink: 0;
      /* Prevent shrinking beyond width */
    }

    .resizer-handle {
      width: 5px;
      /* Width of the draggable area */
      background-color: #ddd;
      /* Make it visible */
      cursor: col-resize;
      /* Indicate it's draggable */
      flex-shrink: 0;
      /* Prevent shrinking */
      height: 100%;
      z-index: 10;
      /* Ensure it's clickable */
      border-left: 1px solid #ccc;
      border-right: 1px solid #ccc;
      box-sizing: border-box;
    }

    .resizer-handle:hover {
      background-color: #bbb;
    }

    .controls-section.card {
      margin-bottom: 20px;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #fff;
    }

    h1,
    h2 {
      margin-top: 0;
    }

    /* Adjust scene container if needed */
    .scene-container {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
    }

    .scene-card {
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 4px;
      width: 200px;
      /* Example width */
      cursor: pointer;
    }

    .scene-card:hover {
      border-color: #aaa;
    }

    .scene-card img {
      max-width: 100%;
      height: auto;
      display: block;
      margin-top: 10px;
    }

    #console-output {
      height: 300px;
      /* Example height */
      overflow-y: scroll;
      border: 1px solid #ccc;
      background-color: #fdfdfd;
      padding: 5px;
    }

    /* --- ADDED Teleprompter Iframe Styles --- */
    .teleprompter-container iframe {
      width: 100%;
      /* Make iframe fill container width */
      max-width: 100%;
      /* Ensure it doesn't overflow */
      height: 180px;
      /* Set a fixed height (adjust as needed) */
      border: none;
      /* Remove default iframe border */
      display: block;
      /* Ensure it behaves like a block element */
    }

    /* --- ADDED Camera Controls Styles --- */
    .camera-control {
      margin-bottom: 20px;
      padding: 15px;
      border: 1px solid #ccc;
      border-radius: 5px;
    }

    .camera-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .remove-btn {
      width: 28px;
      height: 28px;
      padding: 0;
      text-align: center;
      background-color: #fdd;
      border: 1px solid #f99;
      color: #c00;
      cursor: pointer;
      font-size: 1em;
      line-height: 26px;
      flex-shrink: 0;
      border-radius: 3px;
    }

    .remove-btn:hover {
      background-color: #fcc;
      border-color: #f66;
    }

    .camera-preview video {
      width: 100%;
      max-height: 150px;
      background: #000;
      margin-bottom: 5px;
    }

    .device-info {
      font-size: 0.8em;
      color: #666;
      margin-bottom: 10px;
    }

    .camera-settings {
      margin-top: 10px;
    }

    .setting-group {
      margin: 10px 0;
    }

    .setting-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }

    .setting-group select {
      width: 100%;
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 3px;
    }

    .ptz-controls {
      margin-top: 15px;
    }

    .ptz-slider {
      margin: 10px 0;
    }

    .ptz-slider input {
      width: 100%;
    }

    .ptz-slider label {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .camera-controls button {
      margin-top: 10px;
      width: 100%;
      padding: 8px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }

    .camera-controls button:hover {
      background-color: #45a049;
    }

    /* --- Updated PTZ Control Styling --- */
    .ptz-control-group {
      display: flex;
      align-items: center;
      margin: 10px 0;
      width: 100%;
      box-sizing: border-box;
    }

    .ptz-control-group label {
      flex: 0 0 55px;
      text-align: right;
      font-weight: normal;
      margin-right: 10px;
    }

    .ptz-control-group input[type="range"] {
      flex: 1;
      margin: 0 10px 0 0;
      height: 20px;
      width: 100%; /* Ensure all sliders have 100% width */
      min-width: 0; /* Override any browser defaults */
      box-sizing: border-box;
    }

    .ptz-value-display {
      flex: 0 0 45px;
      text-align: right;
      font-family: monospace;
      font-size: 0.9em;
    }

    .ptz-controls-container {
      width: 100%;
      box-sizing: border-box;
      padding: 10px 0;
      border-top: 1px solid #eee;
      border-bottom: 1px solid #eee;
      margin: 10px 0;
    }

    .ptz-placeholder {
      text-align: center;
      color: #999;
      font-style: italic;
      margin: 10px 0;
    }
    /* --- END Updated --- */

  </style>
</body>

</html>